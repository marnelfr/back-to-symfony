## API Platform
Installation: ``composer req api``

To make an entity, an api resource, just add ``#[ApiResource]`` on the
top of the entity.

To display the data send by an api point, add the format as extension
to the link otherwise, api_platform show those data through its
doc.\
e.g.: [https://localhost/api/cheese_listings/2.jsonld](https://localhost/api/cheese_listings/2.jsonld)

## OpenAPI
The Swagger doc generated by api_platform (ap) is generated thanks to 
OpenAPI. We can even display the OpenAPI code generated by ap via
the link [https://localhost/api/docs.json](https://localhost/api/docs.json)\
It's even possible to generate the frontend js code that can 
communicate with our api using **Swagger Codegen**, 
some tools provided by swagger.

## RDF
Stand for **Resource Description Framework**. It's a set of rules about 
how we can describe the meaning of data.
The RDF JsonLD add some extra fields to our json in order to help machine 
understanding our API.

### @id
In a Rest API, every resource is represented by an URL and should have its 
own identifier. That's why thanks to JsonLD, every resource has 
the ``@id`` filed representing when concatenate to our API
domain name, the unique identifier of our resource across the 
entire internet: it's the **IRI** (Internationalized 
Resource Identifier).

### @context
Provide a link to machine to really understand our resource. In our
case, the complete url will be [https://localhost/api/contexts/CheeseListing](https://localhost/api/contexts/CheeseListing)\
Here, every think is listed to help machine understanding really
what our resource actually represent. We can even make it more
informational by providing description for our entities properties.

### @type
A resume from information provided by @context that let machine 
know about our resource's type.


## Profiler
Installation: ``composer req profiler --dev``\
While we can install the debugger ``req debug`` to get some extra 
debug tools in addition to the profiler, it can be installed alone.

### Operations
We've got 2 type of operations:
- **collectionOperation**: doesn't require a resource's Id. It has
  - a GET method: to retrieve a collection of resource
  - a POST method: to create a resource
- **itemOperation**: require a resource's Id and has
  - a GET method to get an unique resource based on its id
  - a PUT method: to edit the whole resource
  - a PATCH method: to only edit some fields of our resource.
  - a DELETE method: to destroy the resource.

So while setting up our resource, we can define which kind or 
operation we want our API to expose:
````php 
#[ApiResource(
    collectionOperations: ['GET', 'POST'],
    itemOperations: ['GET', 'PUT', 'PATCH', 'DELETE'],
)]
````
Removing any of these array value will remove the api endpoint.\
And each of them, we can be customized if transformed into a key
with its config as value:\
``'GET' => ['path' => '/lov/de/{id}']``

## Serializer
It used to convert our resources from object to json before sending
and from json to object before using them in our app.
To do that, it uses the getter and the setter of our entity 
since it use the ObjectNormalizer that employ the 
**PropertyAccess component**.
This mean we can 
- change/delete our resources' json properties by modifying
our getters 
- and change/delete the json properties our api will receive 
by modifying our setters. 
 
### Serialization groups
The normalization is the process turning our resource into an
array. Only the array got from that process is then convert
into JSON and send to the client. So we can pass the **groups** 
option to our **normalizationContext**. Henceforth, only field 
in these group will be considered in the serialization process.
Same thing can be done with **denormalizationContext**.\
Even getter and setter can be added to groups.
````php 
normalizationContext: [
  'groups' => ['read:cheese'], 
  'swagger_definition_name' => 'Read' // make our doc's schemas section more readable
]
````

### Serialized name
We can set the name through witch our resource's properties
will be set:
```php 
#[SerializedName('textDescription')]
private ?string $description = null;
````

## Constructor args
Removing the setter of a property and adding it as a constructor
arg make it **immutable** (can be set only once). We can make it
in our entity, but we should make sure that the arg has the same 
name as the concerned property. Also, **making it nullable is a good
way to prevent a 400 error code when it's not sent**:
````php
public function __construct(string $title = null) {
    $this->title = $title;
}
````

## ApiFilter
A beautiful way to filter our data. It uses a Filter class
and generally the concerned properties:
````php 
#[ApiFilter(BooleanFilter::class, properties: ['isPublished'])]
#[ApiFilter(SearchFilter::class, properties: ['title' => 'partial', 'description' => 'partial'])]
#[ApiFilter(RangeFilter::class, properties: ['price'])]
#[ApiFilter(PropertyFilter::class)]
````
Most Filter classes are in the ``Doctrine/Orm`` namespace so 
thanks to PHPStorm, we can even display all of them. Each of 
them has a quick description of how they can be used.

The **PropertyFilter** however is not in that namespace 
and allow our api client to get only properties 
it needs from those we make available.

## Validation
Validation and API Platform work exactly like in every Symfony app,
and API Platform tacks care of the boring work of mapping serialization
and validation value to a 400 status code and descriptive, consistence
error response.\
We then only need to add **[Validator/Constraints](https://symfony.com/doc/current/validation.html#supported-constraints)** to our classes'
properties and let ap do the remaining work.
















## ApiResource's properties
- (shortName: 'Cheese'): to rename our resource
- (paginationItemsPerPage: 2): to paginate the client request
result up to 2 items per page. Brings use the ``hydra:view`` property
that has useful information.
- (paginationPartial: true): makes lighter the ``hydra:view``
returned information
- (formats: ['jsonld', 'html', 'json', 'csv' => ['text/csv']]):
allow use to add as much format as we want. Always add default
ones when we want to add a new one. Since we added the **CSV** format,
we can then download our api response we such of link: 
[http://localhost/api/cheeses.csv?page=1](http://localhost/api/cheeses.csv?page=1)


  



